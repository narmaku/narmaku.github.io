---
title: Leveraging Aurora OS Distroboxes
author: "narmaku"
date: 2025-10-01 10:00:00 +0900
categories: [Development, Linux]
tags: [ai-generated, ai, linux, dev, os, containers, programming]
---

# Leveraging Aurora OS Distroboxes: The Ultimate Guide



## Introduction

Aurora OS is an **immutable Linux distribution** built on Fedora's "atomic" platform (Universal Blue) and featuring the KDE Plasma desktop[\[1\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=It%20is%20designed%20to%20be,delightfully%20curated%20KDE%20desktop%20experience). In an immutable OS, the core system is read-only and updates are delivered as image upgrades (with easy rollbacks), which ensures a rock-solid base that "gets out of your way" for productivity[\[2\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=Aurora%20is%20an%20operating%20system,%E2%80%9Cultimate%20productivity%20workstation%E2%80%9D%20Image%3A%20%3Asmile). This paradigm shift means you don't install development tools or libraries directly on the host as you would on a traditional Linux. Instead, Aurora embraces containerization and other mechanisms to manage software in a **safe, reproducible** manner[\[3\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=Aurora%20Developer%20Experience%20%60%28aurora,tools%20directly%20on%20the%20host). In this guide, we'll explore all the capabilities of Aurora OS - from using Distrobox containers for development (with GUI and GPU access) to leveraging Flatpak and Homebrew - to help you transition from a traditional Linux workflow to Aurora's **immutable** model with ease.

**What to expect:** We will cover how to set up your development environment on Aurora 42 (KDE edition), including enabling Developer Mode for access to tools like Podman/Docker. You'll learn to use **Distrobox** containers to run and develop various projects (Python, Node.js, etc.), even those with heavy GUI or GPU requirements. We'll also show how to handle CLI tools, web services that expose ports, and other applications using Aurora's recommended approaches (Flatpaks for GUI apps, Homebrew for quick CLI utilities, and rpm-ostree layering only as a last resort). By the end, you'll have a clear roadmap to harness Aurora OS's full power for software development and deployment - **combining the stability of an immutable OS with the flexibility of containers and sandboxed apps**.

## Aurora OS Basics: Immutability and Software Installation

Before diving into development workflows, it's crucial to understand how software management works on Aurora (and similar immutable distros). Unlike traditional package management (apt, dnf, etc. on a mutable system), Aurora provides multiple strategies for installing or running applications:

- **Flatpak for GUI Applications:** Flatpak is the primary method for desktop/GUI apps on Aurora[\[4\]](https://docs.getaurora.dev/guides/software/#:~:text=Flatpak). Aurora comes with the Flathub repository enabled, providing a "unified app store" of popular applications[\[5\]](https://getaurora.dev/en#:~:text=A%20unified%20app%20store). You can install GUI apps (IDEs, browsers, etc.) via KDE Discover or the flatpak command. These apps run in sandboxed environments and won't pollute the base system. If a desired app is available as a Flatpak, prefer this method for simplicity and good integration (Wayland support, portals for file access, etc.).
- **Homebrew for CLI Tools:** Aurora includes Homebrew by default as a convenient way to install command-line utilities in your home directory[\[6\]](https://getaurora.dev/en#:~:text=Homebrew%20on). Homebrew (on Linux) keeps binaries in ~/.linuxbrew and manages its own dependencies, **safely isolated** from the OS libraries[\[6\]](https://getaurora.dev/en#:~:text=Homebrew%20on). This is great for small tools and language runtimes - for example, you can do brew install hugo or brew install httpie to quickly get a tool without affecting the base system. Since it's user-scoped, it won't require root and won't risk breaking system files. (Aurora's integration ensures Homebrew is "on tap" and ready to use out-of-the-box[\[7\]](https://getaurora.dev/en#:~:text=Homebrew%20on).)
- **Distrobox Containers for Everything Else:** Distrobox is a containerized environment (using Podman or Docker under the hood) that allows you to run another Linux distribution's user space on top of Aurora[\[8\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Use%20any%20Linux%20distribution%20inside,X11%2FWayland%29%2C%20and%20audio). It's tightly integrated, meaning the container shares your home directory, networking, display, and devices with the host for a seamless experience[\[9\]](https://wiki.archlinux.org/title/Distrobox#:~:text=you%E2%80%99re%20more%20comfortable%20with,X11%2FWayland%29%2C%20and%20audio)[\[10\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Distrobox%20allows%20users%20to%20partially,shared%20between%20host%20and%20container). **Why use Distrobox?** It gives you access to traditional package managers (dnf, apt, etc.) inside the container[\[11\]](https://docs.getaurora.dev/guides/software/#:~:text=Distrobox%20Containers), so you can install any libraries or development tools you need without touching the immutable host. Aurora's documentation notes two common scenarios for Distrobox: as a _fallback_ to run software that isn't available as a Flatpak, and as **development containers** (isolated environments for building and running projects)[\[12\]](https://docs.getaurora.dev/guides/software/#:~:text=They%20are%20commonly%20used%20for,two%20different%20scenarios). We will focus heavily on using Distrobox for development in this guide.
- **rpm-ostree Layering (Last Resort):** It _is_ possible to install rpm packages on the host via rpm-ostree install, but this is **discouraged** except when absolutely necessary[\[13\]](https://docs.getaurora.dev/guides/software/#:~:text=%60rpm). Layering packages onto an immutable OS can lead to slower or problematic upgrades (dependency conflicts, etc.)[\[14\]](https://docs.getaurora.dev/guides/software/#:~:text=Layer%20RPM%20packages%20to%20the,with%20major%20downsides%20such%20as). Aurora's philosophy _"asks that you do not install your development tools directly on the host"_[\[3\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=Aurora%20Developer%20Experience%20%60%28aurora,tools%20directly%20on%20the%20host) - instead, use containers or user-space package managers. In rare cases when a driver or low-level tool isn't usable via container or Flatpak (for example, certain kernel modules or VPN tools), you might layer an RPM or use an OSTree "repofile" overlay[\[15\]](https://docs.getaurora.dev/guides/software/#:~:text=,this%20as%20a%20last%20resort). But generally, **think container-first** for adding software on Aurora.

In summary, **Aurora OS's tooling ensures you can install virtually anything without breaking the base system**. GUI apps go through Flatpak; CLI tools can use Homebrew; complex dev environments run in Distrobox containers; and direct host installation is a last resort. This approach provides the best of both worlds - a clean, stable OS and flexibility to run what you need - which is ideal for a development workstation. Next, we'll set up the Aurora development environment and then dive into using Distrobox for various development scenarios.

## Setting Up Aurora's Developer Environment

Aurora includes a special "Developer Experience" (DX) mode that bundles common development tools and integrations. On Aurora 42, if you installed the standard image, you may need to **enable Developer Mode** to get all the goodies. Enabling it will install Docker/Podman and other dev tools, and configure your system for container-based workflows (including adding your user to necessary groups). To enable this, open a terminal and run:

`ujust devmode`

Follow the interactive prompts - Aurora's setup assistant will install the Developer Experience components[\[16\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=To%20enable%20Developer%20Mode%20from,will%20look%20something%20like%20this). Once that completes, run:

`ujust dx-group`

This command adds you to the relevant groups (e.g. docker group for Docker/Podman access)[\[17\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=After%20enabling%20Developer%20Mode%2C%20you,yourself%20to%20the%20right%20groups). After running it, **log out and log back in** for group membership changes to take effect. At this point, you should have tools like Podman and Docker available (Aurora DX includes both container engines for your convenience[\[18\]](https://getaurora.dev/en#:~:text=Preinstalled%20container%20tools)), as well as Visual Studio Code (or VSCodium) installed for you[\[19\]](https://getaurora.dev/en#:~:text=Developer%20tools%20are%20a%20click,away). In fact, Aurora-DX comes preconfigured for **DevContainers**, meaning you can use VS Code's remote container features out of the box[\[19\]](https://getaurora.dev/en#:~:text=Developer%20tools%20are%20a%20click,away). It even offers quick installation of JetBrains Toolbox and other IDEs via the ujust command (for example, ujust jetbrains)[\[20\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=,commands).

_Verification:_ You can verify Podman is ready by running podman --version, and Docker by docker --version. Also, try brew --version to see that Homebrew is set up (Aurora automatically configures Homebrew on first use). With Developer Mode enabled, your system is prepared to leverage containers and other dev tools. Aurora's approach is to **"take away the footguns"** by isolating dev tools from the base system[\[21\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=This%20approach%20makes%20managing%20dependencies,of%20the%20following%20features%20that) - now you're ready to see this in action with Distrobox.

## Using Distrobox for Development on Aurora OS

Distrobox will be your workhorse for software development on Aurora. It allows you to spin up containerized environments based on different Linux distributions, all while integrating closely with your Aurora desktop. This means you can install compilers, runtimes, databases - anything - inside a container without worrying about messing up Aurora's base OS. Meanwhile, you'll still be able to access your files, GUI, network, and even GPU from within that container, as if you were on a normal distro. Let's break down how to leverage Distrobox step by step.

### Creating and Managing Distrobox Containers

**Installation:** If not already present, install Distrobox. Aurora's Developer Mode may include it, but if not, you can install it via Homebrew (brew install distrobox) or via Flatpak (if available), or using the official script. Once installed, using Distrobox is done through the distrobox command. (Podman is used under the hood by default on Aurora, since it's rootless and preinstalled[\[18\]](https://getaurora.dev/en#:~:text=Preinstalled%20container%20tools).)

**Create a container:** To create a new container environment, use distrobox create. For example, to create a development container based on Ubuntu 22.04, you could run:

`distrobox create --name dev-ubuntu --image ubuntu:22.04`

This will download the Ubuntu 22.04 image and set up a container named "dev-ubuntu". By default, Distrobox containers share important resources with the host, including your **home directory, the network, IPC, USB devices, and display (X11/Wayland)**[\[9\]](https://wiki.archlinux.org/title/Distrobox#:~:text=you%E2%80%99re%20more%20comfortable%20with,X11%2FWayland%29%2C%20and%20audio)[\[10\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Distrobox%20allows%20users%20to%20partially,shared%20between%20host%20and%20container). This tight integration means once you enter the container, you can access your home files and internet as if on the host, and GUI apps can display on your Aurora desktop. It's not a security sandbox - think of it as an extension of your system for compatibility and development purposes. (Isolation can be increased with flags like --unshare-net if needed, but by default integration is the goal[\[10\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Distrobox%20allows%20users%20to%20partially,shared%20between%20host%20and%20container).)

You can list all Distrobox containers with: distrobox list. Once created, **enter the container** with:

`distrobox enter dev-ubuntu`

Your prompt will change (usually indicating the container name). Now you are "inside" an Ubuntu user space, but with access to your normal \$HOME directory and network. From here, you can use the container's package manager to install development tools. For instance, in an Ubuntu container:

```bash
# inside container shell  
sudo apt update && sudo apt install -y build-essential python3-pip nodejs npm git
```

This would install common compilers and languages (C/C++ toolchain, Python, Node.js, Git, etc.) in the container without any effect on the Aurora host. If you chose a Fedora-based container (for example, distrobox create -i registry.fedoraproject.org/fedora:42 for a Fedora 42 container), you'd use dnf to install packages. The key is **freedom to use whatever distro and package manager you're comfortable with**[\[8\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Use%20any%20Linux%20distribution%20inside,X11%2FWayland%29%2C%20and%20audio) - Distrobox even allows mixing distro versions for compatibility.

Some tips for managing containers:

- You can have multiple containers for different purposes (e.g. one for Python/AI, one for Node.js projects, etc.). Create each with a distinct --name.
- To remove a container: exit it and run distrobox rm &lt;name&gt;. This deletes the container but not any files you created in your mounted home.
- By default, containers are persistent. Any packages you install inside will be there next time you enter. If you ever mess up an environment, you can delete and recreate it from scratch easily.
- You can run a one-off command in a container without interactive shell using: distrobox enter &lt;name&gt; -- command. For example: distrobox enter dev-ubuntu -- python3 --version will run Python in the container and return the output.
- **Integration with host:** If you install an application inside the container that you'd like to launch from your host's desktop environment, use distrobox-export. For example, inside the container you could run: distrobox-export --app firefox (if you had Firefox installed in the container). This would create a launcher on your Aurora desktop so that "Firefox (dev-ubuntu)" appears in your application menu and, when clicked, it transparently starts the container (if not running) and launches the app[\[22\]](https://wiki.archlinux.org/title/Distrobox#:~:text=If%20you%20encounter%20an%20authorization,not%20starting%20for%20the%20fix). This is very handy for GUI apps not available as Flatpak.

**Networking & Ports:** Because Distrobox containers share the host network namespace by default, any server you run inside the container will be accessible as if it's running on the host[\[10\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Distrobox%20allows%20users%20to%20partially,shared%20between%20host%20and%20container). For example, if you run a web app on port 5000 inside the container, you can open <http://localhost:5000> on your Aurora host and access it. There is no need to do complex port forwarding - this "feels" like a normal machine in that respect. (If you prefer isolation, you could create a container with --unshare-net which would then require explicit port mapping, but typically for development you want host networking for convenience.) This is great for testing web applications or APIs locally. If you need a service in the container to always run in background (even when you're not manually "inside" it), consider using Aurora's **Quadlet** system or Podman's systemd integration to manage it as a service[\[23\]](https://docs.getaurora.dev/guides/software/#:~:text=,Developer%20Experience) - but that's an advanced topic beyond this guide's scope. For development and interactive use, you'll usually just start processes as needed when inside the container.

Now that we have our container set up, let's talk about running applications - including graphical apps - and accessing hardware like the GPU from within these containers.

### Running Graphical Applications from a Container

One of the coolest features of Distrobox on Aurora is that you can run GUI applications from within the container and have them display on your host desktop. Because your X11/Wayland display sockets and necessary environment variables are shared, most GUI apps "just work." For example, you could install a Linux GUI app that isn't packaged on Flathub (say a specific IDE or tool) inside the container and launch it with no noticeable difference from a natively installed app.

**Requirements:** If your container distro is minimal, you may need to install GUI support libraries. In particular, ensure the container has **Mesa drivers** for graphics. For instance, on Fedora containers run sudo dnf install -y mesa-dri-drivers, on Ubuntu/Debian run sudo apt install -y mesa-utils mesa-va-drivers (or the relevant mesa packages for your GPU)[\[24\]](https://wiki.archlinux.org/title/Distrobox#:~:text=When%20running%20graphical%20apps%2C%20you,Mesa%20package%20for%20the%20distro). Distrobox will try to install some mesa/DRI drivers automatically for Intel/AMD GPUs, but it's good to confirm. Mesa provides OpenGL/Vulkan support so that GUI apps can use 3D acceleration via the host's GPU (more on GPU specifics in the next section).

Once that's set, you can launch GUI programs from the container. If you're already inside via distrobox enter, simply run the program's command (e.g. codium & or firefox &) and it should appear on your Aurora desktop. You can also launch directly from the host using the distrobox enter -- &lt;app&gt; syntax[\[25\]](https://wiki.archlinux.org/title/Distrobox#:~:text=starting%20%20for%20the%20fix), which spawns the app without you manually opening a shell. For seamless usage, consider the distrobox-export tip mentioned earlier to create menu entries for frequently used container apps[\[25\]](https://wiki.archlinux.org/title/Distrobox#:~:text=starting%20%20for%20the%20fix).

**Wayland vs X11:** Aurora uses a Wayland-based KDE session by default. Distrobox shares both X11 and Wayland sockets, so applications inside the container can use either protocol to display[\[9\]](https://wiki.archlinux.org/title/Distrobox#:~:text=you%E2%80%99re%20more%20comfortable%20with,X11%2FWayland%29%2C%20and%20audio). Many apps will automatically detect the Wayland environment. For example, if you run a modern app (GTK4, Qt6, etc.) inside the container, it may render via Wayland on your host. Older or non-native apps will fall back to X11, which is transparently handled by Aurora's XWayland compatibility layer. In short, you usually don't need to do anything special - the \$DISPLAY and \$WAYLAND_DISPLAY environment variables and sockets are set up such that GUI apps know how to connect out.

**Troubleshooting display access:** In some cases, you might encounter an error like Error: Can't open display :0 or Authorization required, but no authorization protocol specified when launching an X11 app from inside the container. This is due to X11's access control (the container user needs permission to use your X server). One quick fix is to run on the host: xhost +SI:localuser:\$USER, which allows your local user to connect to the X server from inside containers. (This essentially bypasses the MIT-MAGIC-COOKIE auth for local processes.) The ArchWiki notes that using the xauth tool to merge your host X credentials into the container is a more fine-grained solution[\[26\]](https://wiki.archlinux.org/title/Toolbox#X11_applications_not_starting#:~:text=Authorization%20required%2C%20but%20no%20authorization,Error%3A%20Can%27t%20open%20display%3A%20%3A0), but the xhost method is simpler for a development box. After granting access, retry launching the app. Once the GUI pops up, you should have full functionality - including audio, since PulseAudio/PipeWire sockets are also typically shared by Distrobox by default[\[9\]](https://wiki.archlinux.org/title/Distrobox#:~:text=you%E2%80%99re%20more%20comfortable%20with,X11%2FWayland%29%2C%20and%20audio).

In practice, many Aurora users have reported smooth sailing with GUI apps in containers. For example, one might run VSCodium (VS Code without telemetry) inside a toolbox/distrobox and use it like a native app. In a Fedora Silverblue (immutable OS) tutorial, the author installs Node.js and VSCodium inside a container, then starts VSCodium and it launches on the host display to edit project files[\[27\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=)[\[28\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=npm%20create%20astro%40latest). This demonstrates that even full-fledged IDEs can run inside your Distrobox. You can adopt a similar approach: install your IDE or GUI tool inside the container if you prefer not to use the Flatpak or host version, then export or launch it as needed.

### Accessing Hardware (GPU, USB, etc.) from Distrobox

**USB Devices and Others:** Because Distrobox by default shares /dev and the udev database with the host[\[29\]](https://wiki.archlinux.org/title/Toolbox#X11_applications_not_starting#:~:text=Toolbox%20is%20a%20tool%20that,and%20the%20udev%20database%2C%20etc), most hardware devices connected to your machine are visible inside the container. For example, if you have a USB serial device (tty), or an external drive, you can access it from the container (the same device path under /dev). This is convenient for development involving microcontrollers or other hardware - just be mindful that the container user might need appropriate group permissions (you can manage that similarly to on a normal distro). The integration extends to things like the system DBus and ulimits as well[\[29\]](https://wiki.archlinux.org/title/Toolbox#X11_applications_not_starting#:~:text=Toolbox%20is%20a%20tool%20that,and%20the%20udev%20database%2C%20etc), so in general the container can interact with host services if needed (though sensitive operations might still require host-side setup).

**GPU Acceleration (Intel/AMD):** If you plan to do graphics-intensive development or AI processing, GPU access is essential. For Intel and AMD GPUs using open-source drivers, Distrobox support is largely automatic. The container will use the Mesa drivers (as long as installed) to interface with the GPU through the host's kernel driver[\[30\]](https://distrobox.it/useful_tips/#:~:text=Using%20the%20GPU%20inside%20the,container). Since the /dev/dri devices (for DRM/Render nodes) are shared, apps inside the container can utilize OpenGL, Vulkan, VA-API, etc., by leveraging the host's GPU. For instance, you can run GUI apps that use 3D acceleration or video decode (like Blender, or ML frameworks using OpenCL) inside the container with near-native performance. Just ensure the container's Mesa version is new enough to support your GPU features. Typically, matching or close to host Mesa version is fine - using a recent distro image helps. In summary, **Intel/AMD GPUs work out-of-the-box in Distrobox**; you can confirm by running a quick test like glxinfo | grep "OpenGL renderer" inside the container and you should see your GPU name, or run vulkaninfo for Vulkan (you may need to install those tools in container).

**GPU Acceleration (NVIDIA):** For NVIDIA GPUs, the setup is a bit more involved due to proprietary drivers. Aurora provides an ISO variant with NVIDIA drivers preinstalled (if you selected the NVIDIA edition ISO, your host already has the driver)[\[31\]](https://getaurora.dev/en#:~:text=Expanded%20hardware%20support)[\[32\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=%2A%20AMD%2FIntel%3A%20https%3A%2F%2Fdl.getaurora.dev%2Faurora,stable.iso). To pass NVIDIA support into a container, Distrobox offers an --nvidia flag on creation. This flag will mount the host's NVIDIA driver libraries and device nodes into the container so that you **don't have to install the NVIDIA driver inside the container**[\[33\]](https://distrobox.it/usage/distrobox-create/#:~:text=NVidia%20integration). For example:

`distrobox create --name dev-ubuntu-gpu --image ubuntu:22.04 --nvidia`

When you enter this container, it should have access to CUDA/OpenGL via the host driver. This feature was introduced in Distrobox v1.5+ to share the host's NVIDIA support with containers[\[34\]](https://www.phoronix.com/news/Distrobox-1.5-Released#:~:text=With%20today%27s%20Distrobox%201,driver%20support%20with%20the%20container). It requires that the host is using the proprietary NVIDIA driver (and not a purely flatpak-sandboxed driver). Aurora's "Nvidia Open" edition (for Turing+ cards) includes the open kernel module and proprietary userland, which works with this integration[\[32\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=%2A%20AMD%2FIntel%3A%20https%3A%2F%2Fdl.getaurora.dev%2Faurora,stable.iso)[\[35\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=now). Inside such a container, running nvidia-smi should show your GPU, and GL/Vulkan applications should run with GPU acceleration.

A few notes for NVIDIA:

- The --nvidia flag works on many common distros (Ubuntu, Fedora, Arch, etc.) as long as they use glibc[\[33\]](https://distrobox.it/usage/distrobox-create/#:~:text=NVidia%20integration). It essentially injects the needed driver files. You may still need to install CUDA or other GPU libraries inside the container if your application requires them (for example, install cuda-toolkit or NVIDIA's CUDA runtime if you plan to compile CUDA code). But for using GPU-accelerated libraries (like TensorFlow or PyTorch with CUDA), often just sharing the driver is enough, as those libraries bring their own CUDA binaries which will utilize the host driver.
- Alternatively, you can use NVIDIA's Container Toolkit approach. If you installed nvidia-container-toolkit on the host (Aurora DX might include this for you under the hood), you could create a Distrobox with --additional-flags "--gpus all" to achieve similar GPU pass-through[\[36\]](https://distrobox.it/useful_tips/#:~:text=Using%20nvidia). The Distrobox docs mention using an official CUDA base image in this case[\[37\]](https://distrobox.it/useful_tips/#:~:text=In%20case%20of%20podman%20container,manager%2C%20run). For example: distrobox create --name cuda-test --image docker.io/nvidia/cuda:12.2-runtime-ubuntu22.04 --additional-flags "--gpus all". This would give you a container with NVIDIA's CUDA environment ready. This is more of an advanced use-case, but it can be useful if you want a preconfigured environment for AI development (NVIDIA publishes container images for PyTorch, TensorFlow, etc., which you can run via Distrobox or directly with Podman/Docker).

**Local AI/ML Workflows:** Aurora is explicitly designed to support local AI workloads - it includes GPU drivers and common AI utilities to make it easy to run AI software on your GPU[\[38\]](https://getaurora.dev/en#:~:text=applications%20into%20one%20package). In practice, this means you can, for example, run Stable Diffusion or train models on your machine using containers. A recommended approach is to use a container (or Distrobox) to manage the Python environment for AI projects. For instance, you might create a container for PyTorch development:

`distrobox create --name pytorch-dev --image fedora:38 --nvidia`

Then inside it, enable the official PyTorch repository or just use pip to install torch. The container can isolate the heavy Python dependencies from your host. You could also use Conda or Mamba inside the container if you prefer, to manage packages in a more controlled way (since Aurora doesn't ship Conda, doing it in container avoids cluttering your home with large miniconda environments). The combination of Aurora + Distrobox + GPU support means you can iterate on AI experiments with full hardware acceleration, and if something breaks or conflicts (say different projects need different CUDA or library versions), you can simply spin up separate containers for each. No more "DLL hell" or breaking your system Python - each container is its own universe. And thanks to host sharing, you can still display any UI (for example, if you use Jupyter Notebook from the container, you can access it via browser on host; if you use an app with an interface like _Stable Diffusion WebUI_, it will open a local web service accessible on host).

### Development Workflow Examples with Distrobox

Now, let's tie it all together with a couple of concrete workflows - one for a **Node.js web application** and one for a **Python AI project** - to illustrate how you might use Aurora and Distrobox in day-to-day development.

**Example 1: Node.js Web Application (with GUI IDE)**  
Suppose you want to develop a Node.js web app (perhaps using a framework like Astro or React) on Aurora. You also want to use VS Code (or VSCodium) as your editor. Here's how you could do it:

- **Create a Node.js container:** Using Fedora Silverblue as an analogy, one might create a Fedora toolbox with Node installed[\[39\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=). On Aurora with Distrobox, you can do similarly. For instance:

`distrobox create --name nodebox --image registry.fedoraproject.org/fedora-toolbox:42`

Then enter it: distrobox enter nodebox, and install Node.js. On Fedora: sudo dnf install -y nodejs npm. (Fedora's repo has Node.js by default[\[40\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=).) Alternatively, you could choose an official Node Docker image as your base (--image docker.io/library/node:18), but using a standard distro gives you a full package manager for other tools too.

- **Set up your development tools in container:** Install any other tools you need. E.g., in the container run: sudo dnf install -y git python3 if you need Git and Python, etc. If you want to run an editor inside the container, you can install it now (the blog example installed VSCodium inside the container[\[27\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=)). For VSCodium on Fedora, they added a repo and installed codium[\[41\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=Now%20we%20add%20the%20always,to%20date%20repository%20of%20paulcarroty)[\[42\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=And%20install%20with%20DNF). You could follow those steps, or if you prefer VS Code's Flatpak on the host, you might skip installing an editor in the container. Let's assume we'll use the host's VS Code for a moment.
- **Create a project directory:** You can do this on the host or inside container (since they share home, it doesn't really matter). For organization, maybe create ~/Development/my-app. Inside the container, cd ~/Development (this is actually the host's folder) and then use a starter tool. For example, to create a new Astro project:

```bash
mkdir -p ~/Development && cd ~/Development  
npm create astro@latest
```

This will prompt for some options and then generate a project (say, an Astro blog) in a subdirectory[\[43\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=Astro%20Blog)[\[28\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=npm%20create%20astro%40latest). After generation, cd into the project folder (cd my-astro-blog).

- **Launch the development server:** Still in the container, you can start the app's dev server. For Astro, that might be npm run dev or astro dev[\[44\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=codium%20). The server will start and bind to localhost (port 3000 or Astro uses 4321 by default). Thanks to host networking, you can open your browser on Aurora and go to <http://localhost:4321> and see the running web app.
- **Edit with your IDE:** You have two options:
- **Host IDE (Flatpak VS Code):** If you have VS Code installed on Aurora (for example, via Flatpak or the Aurora DX default), you can open the project folder from the host. The Node.js runtime is in the container, but you can still edit files on host since they're just your home files. To run or debug inside the container, you could use VS Code's Remote Containers extension (DevContainers). Aurora's DX is preconfigured for this, so if you open the project in VS Code and you have a .devcontainer config, it can attach to the Distrobox automatically. Alternatively, you can simply use your host VS Code terminal but enter the container by distrobox enter nodebox for running commands.
- **In-Container IDE:** If you installed VSCodium or another editor inside the container, you can launch it from the container. For example, run codium . inside ~/Development/my-astro-blog[\[45\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=Navigate%20into%20the%20directory%20,and%20launch%20VSCodium%20to%20begin). Thanks to Distrobox's GUI support, the VSCodium window will appear on your KDE desktop[\[28\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=npm%20create%20astro%40latest), and it's running inside the container (so if you open a terminal panel in it, that's a container terminal with all your tools). This is exactly what the Silverblue example did: after scaffolding the Astro project, they ran codium . to start the editor inside the toolbox[\[28\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=npm%20create%20astro%40latest). You can then use it normally to edit files. The advantage here is that any build or debug you do in the IDE will use the container's environment (which has Node, etc., installed).
- **Run/test as needed:** As you edit, your dev server might autoreload. If you need to install additional npm packages, do so in the container. You can also open new terminals (either separate distrobox enter sessions or within the editor's terminal) to run other commands (like running tests, using npx for tools, etc.). Everything you do remains isolated in **nodebox** container; your Aurora host stays untouched by npm or Node installations.
- **Persist or Export (optional):** If this container setup is something you'll reuse, great - the next time you want to hack on the project, just distrobox enter nodebox and everything is as you left it. If you want to make it even easier, you could export the dev server or editor as an app. For example, run inside container: distrobox-export --app codium. This would let you launch "VSCodium (nodebox)" from your KDE menu directly. You could also export a custom command that opens a terminal in the project directory. But these are conveniences - the core idea is you now have a functional dev environment.

With this workflow, we achieved parity with a traditional system (we wrote code, ran a dev web server, used an IDE with intellisense, etc.), but we did it all without installing Node.js or any dev dependency on Aurora itself. The container can be tailored per project (different Node versions, etc. - you could even use NVM inside the container to manage Node versions). And if something goes wrong or you need a clean slate, you can dispose of or rebuild the container easily.

**Example 2: Python Machine Learning Project (with GPU)**  
Now consider you want to experiment with a Python project that uses heavy libraries like NumPy, SciPy, or even GPU-accelerated libraries like PyTorch or TensorFlow. These often have complex dependencies (native libraries, specific version requirements) that can be painful on a base system. On Aurora, you'll isolate this in a Distrobox:

- **Create a Python dev container:** Let's make an environment for Python work, with GPU support. Suppose you have an NVIDIA GPU and want PyTorch with CUDA. We'll base on an Ubuntu image for variety. Run:

`distrobox create --name pybox --image ubuntu:22.04 --nvidia`

This uses Ubuntu 22.04 and integrates the NVIDIA driver from host[\[33\]](https://distrobox.it/usage/distrobox-create/#:~:text=NVidia%20integration). Enter it: distrobox enter pybox.

- **Install Python and science libs:** Ubuntu 22.04 should have Python3 by default, but you might need build tools. Do: sudo apt update && sudo apt install -y python3-pip python3-venv build-essential. If you plan to use Jupyter or other tools: apt install -y jupyter-core jupyter-notebook (or use pip for these inside a venv). For ML, you might directly install via pip inside a virtual environment. For example, in container:

```bash
python3 -m venv ~/envs/torch-env  
source ~/envs/torch-env/bin/activate  
pip install numpy scipy torch torchvision matplotlib jupyter
```

This creates a Python virtual environment in your home (which is on host filesystem, under ~/envs/ in this case) and installs PyTorch and related packages. Because we used --nvidia, PyTorch's CUDA should detect the GPU. You can verify by running a quick test in Python:

```bash
import torch  
print(torch.cuda.is_available())
```

It should return True (assuming you installed the CUDA-enabled PyTorch wheel and your GPU driver is set). If using an AMD GPU, you might install ROCm version of Torch or rely on CPU - but the point is, all these libraries are installed in the container/venv, not on your host. The host remains clean.

- **Run your workload or app:** Now you can run any Python script or Jupyter Notebook. For instance, start a Jupyter Notebook server: jupyter notebook --no-browser --ip=0.0.0.0 --port=8888. It will listen on container's port 8888, which is effectively host port 8888 due to shared networking. You can open <http://localhost:8888> in Aurora's browser and access the Jupyter interface. Use it to run Python code that utilizes the GPU. It will execute inside the container, but you interact from your host browser - a very smooth setup for data science work. If you prefer using VS Code for Python, you could use the VS Code on host and attach to the container's Python environment (the Python extension in VS Code can be pointed to the interpreter in ~/envs/torch-env/bin/python since that's on your shared home, or use the VS Code Remote Containers feature again).
- **GUI application in Python container:** Suppose your Python project has a GUI (maybe using Tkinter or PyQt) or you want to visualize things with Matplotlib pop-up windows. This will also work: since X/Wayland is shared, any GUI from Python (like matplotlib.pyplot.show() or an OpenCV imshow window) will display on your desktop. Ensure you have installed python3-tk or the appropriate GUI toolkit in the container if needed.
- **Cleanup or reuse:** Like before, this environment can be reused anytime by distrobox enter pybox. The virtual environment lives in your home, so it's persisted. If you wanted to start fresh, you could delete the venv or the entire container. Nothing has tainted Aurora - all Python packages (which often are hundreds of MBs) stayed in the container or home directory.

This Python example shows how even complicated setups (CUDA drivers, Jupyter servers, large Python libraries) can be managed in a contained way. Aurora's own claim is that _"including GPU drivers and commonly used utilities for local AI, Aurora makes it easy to get started with running your own AI at home"_[\[38\]](https://getaurora.dev/en#:~:text=applications%20into%20one%20package), and indeed leveraging containers is how you accomplish that without dependency nightmares.

### Tips for an Efficient Workflow

- **Container Choice:** Use a base image that matches your needs. Fedora-based containers integrate very well on Aurora (since Aurora itself is Fedora-based, there's a lot of compatibility). But if your project targets Ubuntu or Debian, you can use those to mirror production. Distrobox supports dozens of distros. You can even run an Arch Linux container on Aurora if you want access to AUR packages - truly "forward compatibility" on any host[\[8\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Use%20any%20Linux%20distribution%20inside,X11%2FWayland%29%2C%20and%20audio). Keep in mind glibc-based images work best for things like --nvidia (as noted earlier)[\[33\]](https://distrobox.it/usage/distrobox-create/#:~:text=NVidia%20integration).
- **Performance:** Running in a container has minimal overhead (it's not a VM). CPU and GPU intensive tasks will run at native speed. I/O to your home directory is essentially direct. One thing to note is that **package installation** in a container may be a bit slower for the very first time if using copy-on-write layers. But this is negligible in most cases. If using rootless Podman, enabling fuse-overlayfs is a tip for speed, but kernel 5.11+ already improves overlay performance[\[46\]](https://distrobox.it/useful_tips/#:~:text=%5Bstorage%5D%20driver%20%3D%20) - Aurora's kernel should be modern enough.
- **Persisting configuration:** If you find yourself setting up the same environment repeatedly for new projects, consider using **Distrobox assemble** (with a config file) or writing a simple script (Dockerfile/Containerfile) to automate creation. The Silverblue web dev guide demonstrates writing a Containerfile and script to automate building a toolbox with Node, Fish shell, and VSCodium preinstalled[\[47\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=touch%20)[\[48\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=). You could adapt that approach with Podman on Aurora. This allows you to spin up a ready-to-go dev container in one command.
- **Security:** Remember that Distrobox containers are not locked down. They are meant for convenience and integration, not security isolation[\[49\]](https://wiki.archlinux.org/title/Distrobox#:~:text=The%20main%20goal%20of%20Distrobox,home%20folder%20and%20application%20directories). So don't treat a dev container as a security boundary - a malicious program running inside it could theoretically affect your home files or snoop on your X11. Continue to practice normal security (only run code you trust, etc.). If you do need stronger isolation for testing untrusted code, you might use a VM or set up a container with --unshare-all to isolate it at the cost of convenience[\[10\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Distrobox%20allows%20users%20to%20partially,shared%20between%20host%20and%20container).

Now that we have thoroughly covered container-based workflows, let's touch on the other methods for completeness: using Homebrew and Flatpak on Aurora for cases where they make sense.

## Using Homebrew for Command-Line Tools

Aurora's inclusion of Homebrew is a quality-of-life feature for developers. Many programming languages and small utilities can be installed quickly with Homebrew, without needing a container or Flatpak. The benefit is simplicity - one command and you have the tool, and it's confined to your home directory. For example, if you need the latest version of a CLI tool like awscli or jq, or perhaps a language runtime like Ruby or a specific version of Node.js, you can run:

`brew install jq` or `brew install node@18`

This will download and install the package under ~/.linuxbrew. Aurora's environment is set up so that ~/.linuxbrew/bin is in your PATH, meaning the installed tool will be immediately usable in your terminal[\[6\]](https://getaurora.dev/en#:~:text=Homebrew%20on). Homebrew also handles dependencies for you. For instance, brew install node@18 would also install any required libraries. Using Homebrew in Aurora is safe because it **"never messes with your host system"** and keeps everything isolated[\[6\]](https://getaurora.dev/en#:~:text=Homebrew%20on).

Some use cases for Homebrew on Aurora:

- Installing Unix utilities or dev tools that are single binaries (e.g., fzf, ripgrep, neovim, tmux). Rather than making a container or layering an RPM, just brew install them.
- Language version managers: Homebrew can install tools like pyenv, rbenv, or even itself manage multiple versions of languages. If you prefer not to use containers for language versioning, this is an option. (Do note, however, that if your development requires compiling large libraries or using many system headers, a container/toolbox might still be cleaner.)
- Quick updates: Brew can easily update a tool (brew upgrade). Since these are user-space, you don't have to reboot or worry about OSTree. It's separate from the OS lifecycle.

Essentially, Homebrew fills the gap for command-line apps that don't have Flatpaks. It complements the container approach: you wouldn't use brew to install something huge like TensorFlow (that's better in a container or a virtual env), but for smaller programs or libraries that you need globally, it's perfect.

**Example:** Suppose you want to use npx to run some Node tool globally (without a project). Instead of setting up a container for one-off use, you might do brew install node to get Node.js on your path. This might be sufficient for quick usage (the Node formula would install under brew). However, be mindful that heavy use of brew for development (like compiling big packages) will consume space in your home and possibly require brew's GCC or libraries that duplicate some of the system. It's a trade-off - containers keep heavy stuff isolated, brew gives quick access. You have both at your disposal on Aurora, which is a strength.

## Using Flatpak for GUI Applications

We touched on Flatpak earlier, but let's emphasize: whenever you need a desktop application, **check Flathub first**. The Discover software center on Aurora (or flatpak search &lt;name&gt;) can help find if the app is available[\[4\]](https://docs.getaurora.dev/guides/software/#:~:text=Flatpak). Flatpaks are easy to install (flatpak install flathub com.company.App), update (flatpak update), and remove, all without affecting the base system. They run sandboxed but with user permissions you can adjust via Flatseal if needed.

Aurora promotes Flatpak as _"a unified one-stop shop for app developers and users alike"_[\[5\]](https://getaurora.dev/en#:~:text=A%20unified%20app%20store) - it really helps to make an immutable system feel like any other distro for daily use. For development specifically, you might use Flatpak for IDEs (e.g., JetBrains IDEs are on Flathub, VS Code OSS (Codium) is on Flathub, etc.), for database clients, design tools, etc. Using the Flatpak version of an IDE while your code runs in a container is a perfectly fine combo (just ensure the IDE has access to your files, which it will by default for home, or via portals).

One case to consider: GUI applications that need direct hardware access (like an OpenGL game or an FPGA programming UI). Many of these work via Flatpak if they use the proper portals or have permissions (e.g., Flatpak can allow GPU access and USB device access if you give it permission). If an app like that isn't on Flathub, you could attempt to run it in Distrobox instead. For instance, some proprietary IDE that is only available as a .deb package - you could install it inside a Debian-based Distrobox and export it. The downside is that you won't have as fine-grained sandboxing as Flatpak, but at least your host remains untouched and you can remove the container when done. Always weigh if there's a Flatpak or Snap (though Aurora doesn't include Snap by default, you could theoretically use snap inside a container too).

**Example:** If you need to run a GUI app that controls hardware (say an Arduino IDE or a PCB design tool requiring USB access to programmers), you could check for a Flatpak (Arduino IDE is on Flathub). If not available, run it in Distrobox - since /dev/ttyACM0 (the Arduino) would be visible in container and the GUI will display on host, it should function normally. This underscores how **Aurora can handle even niche use-cases** via containers if standard packaging isn't available.

## Deploying and Running Services on Aurora

Finally, a note on deploying applications or services permanently. As a developer, once you've built your project, you might want to run it continuously or at startup (for example, a local web service, a database, or an automation script). On traditional Linux, one might use systemd or docker-compose. On Aurora, the recommended approach is to use Podman's systemd integration or **Quadlet** for rootless service management[\[23\]](https://docs.getaurora.dev/guides/software/#:~:text=,Developer%20Experience).

Quadlet allows you to write simple .container files (in /etc/containers/systemd or ~/.config/containers/systemd) which define container-based services. Instead of raw docker-compose, you basically define what image to run, volumes, ports, etc., and systemd manages it. Aurora's docs include a guide "Running Services Using Quadlet"[\[50\]](https://www.reddit.com/r/linux4noobs/comments/1jbh63y/installing_vpn_apps_on_immutable_distros_aurora/#:~:text=Installing%20VPN%20apps%20on%20Immutable,dev%2Fguides%2F) that you can refer to for details. The advantage is you keep the immutability and containerization, but still get auto-starting services if needed.

For example, if you developed a Node.js app and containerized it, you could build a small image for it and use Quadlet to run it on startup (or simply use podman generate systemd from your dev container). Or if you want to run a database server for your projects, you could run a Postgres container via Quadlet. This is beyond development and into deployment, but it shows that Aurora can handle not just dev but also running services reliably via containers.

**Rolling back and updates:** Because the OS updates don't affect your containers or homebrew, you can update Aurora (which happens automatically in the background[\[51\]](https://getaurora.dev/en#:~:text=Aurora%20downloads%20and%20applies%20updates,take%20care%20of%20your%20updates)) without worrying about losing your dev setup. After a reboot into a new OS version, your Distroboxes and Flatpaks are all still there. If an OS update ever caused an issue, you can boot into the previous version (OSTree rollback) easily[\[52\]](https://getaurora.dev/en#:~:text=We%20built%20Aurora%20on%20completely,Resilient%20against%20failure) - though such cases are rare. Your development workflow is largely decoupled from the OS upgrades.

## Conclusion

Transitioning from a traditional Linux distro to an immutable OS like Aurora might seem daunting at first, but as we've shown in this guide, Aurora provides a rich toolset to make it not only painless but actually **more powerful** for development. By leveraging Distrobox containers, you get the freedom of a full Linux environment for each project or toolchain, all while Aurora's base remains stable and consistent. You can run anything from a simple CLI script to a complex GUI application or AI model training session within these containers. And you're not constrained to one distro's userland - you can pull in the best of Ubuntu, Fedora, Arch, etc., on demand[\[8\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Use%20any%20Linux%20distribution%20inside,X11%2FWayland%29%2C%20and%20audio).

Aurora OS, with its **KDE Plasma interface and Developer Experience**, is truly an "ultimate productivity workstation" as the team envisioned[\[2\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=Aurora%20is%20an%20operating%20system,%E2%80%9Cultimate%20productivity%20workstation%E2%80%9D%20Image%3A%20%3Asmile). It supports all major hardware out of the box - including NVIDIA GPUs for gamers and AI developers[\[31\]](https://getaurora.dev/en#:~:text=Expanded%20hardware%20support) - and integrates modern workflows like cloud-native containerization at the desktop level. We recommend the following practices to maximize your productivity on Aurora:

- **Use Flatpaks for GUI apps** whenever possible (for convenience and security isolation).
- **Use Distrobox for development environments** - treat containers as your mutable space for coding, compiling, and running apps that aren't in Flatpak.
- **Use Homebrew for quick installs of CLI tools** or languages, especially when you don't need the overhead of a full container.
- **Keep the host clean** - avoid layering RPMs unless absolutely needed (and if so, remove them once done). This keeps system updates hassle-free[\[14\]](https://docs.getaurora.dev/guides/software/#:~:text=Layer%20RPM%20packages%20to%20the,with%20major%20downsides%20such%20as).
- **Take advantage of Aurora's DX tools** - e.g., VS Code with Dev Containers, or ujust commands to quickly set up common dev tools[\[20\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=,commands). These can save you time in configuring your environment.
- **Don't fear trying new things in containers** - you can always destroy a container and start fresh without any leftover effects. This is great for experimenting or using different versions of software side by side (Python 3.11 in one container vs 3.9 in another, etc.).

By following this guide and embracing Aurora's container-centric workflow, you'll find that developing and deploying software is **just as easy, if not easier, than on a traditional Linux**, with the added benefit that your base system remains uncluttered and reliable. Aurora's philosophy is to empower you to "develop faster than ever before"[\[53\]](https://getaurora.dev/en#:~:text=Welcome%2C%20it%27s%20your%20new%20desktop), and indeed, once you get comfortable with Distrobox and the other tools, you'll likely enjoy the reproducibility and cleanliness of your setup. Welcome to immutable Linux - a modern developer's paradise! Happy coding and deploying on Aurora OS.

**Sources:** The information and steps above were compiled from Aurora's official documentation and community guides, as well as general Distrobox usage references. Key references include Aurora's docs on software installation (Flatpak, Homebrew, Distrobox)[\[54\]](https://docs.getaurora.dev/guides/software/#:~:text=Distrobox%20Containers)[\[13\]](https://docs.getaurora.dev/guides/software/#:~:text=%60rpm), the Aurora DX introduction emphasizing containerized dev workflows[\[3\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=Aurora%20Developer%20Experience%20%60%28aurora,tools%20directly%20on%20the%20host)[\[55\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=Scope%20of%20Development%20Tools), and Distrobox's own documentation detailing GPU support and tight host integration[\[30\]](https://distrobox.it/useful_tips/#:~:text=Using%20the%20GPU%20inside%20the,container)[\[9\]](https://wiki.archlinux.org/title/Distrobox#:~:text=you%E2%80%99re%20more%20comfortable%20with,X11%2FWayland%29%2C%20and%20audio). Real-world usage scenarios were informed by a Fedora Silverblue development guide[\[43\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=Astro%20Blog)[\[28\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=npm%20create%20astro%40latest), which closely parallels how one would work on Aurora. These sources and others have been cited throughout the guide for further reading and verification. Enjoy your journey with Aurora OS - leveraging the best of immutability and flexibility for software development![\[54\]](https://docs.getaurora.dev/guides/software/#:~:text=Distrobox%20Containers)[\[38\]](https://getaurora.dev/en#:~:text=applications%20into%20one%20package)

[\[1\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=It%20is%20designed%20to%20be,delightfully%20curated%20KDE%20desktop%20experience) [\[2\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=Aurora%20is%20an%20operating%20system,%E2%80%9Cultimate%20productivity%20workstation%E2%80%9D%20Image%3A%20%3Asmile) [\[32\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=%2A%20AMD%2FIntel%3A%20https%3A%2F%2Fdl.getaurora.dev%2Faurora,stable.iso) [\[35\]](https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463#:~:text=now) Aurora Stable is now based on Fedora 42 - Aurora - Universal Blue

<https://universal-blue.discourse.group/t/aurora-stable-is-now-based-on-fedora-42/8463>

[\[3\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=Aurora%20Developer%20Experience%20%60%28aurora,tools%20directly%20on%20the%20host) [\[16\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=To%20enable%20Developer%20Mode%20from,will%20look%20something%20like%20this) [\[17\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=After%20enabling%20Developer%20Mode%2C%20you,yourself%20to%20the%20right%20groups) [\[20\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=,commands) [\[21\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=This%20approach%20makes%20managing%20dependencies,of%20the%20following%20features%20that) [\[55\]](https://docs.getaurora.dev/dx/aurora-dx-intro/#:~:text=Scope%20of%20Development%20Tools) Aurora DX Introduction | Aurora

<https://docs.getaurora.dev/dx/aurora-dx-intro/>

[\[4\]](https://docs.getaurora.dev/guides/software/#:~:text=Flatpak) [\[11\]](https://docs.getaurora.dev/guides/software/#:~:text=Distrobox%20Containers) [\[12\]](https://docs.getaurora.dev/guides/software/#:~:text=They%20are%20commonly%20used%20for,two%20different%20scenarios) [\[13\]](https://docs.getaurora.dev/guides/software/#:~:text=%60rpm) [\[14\]](https://docs.getaurora.dev/guides/software/#:~:text=Layer%20RPM%20packages%20to%20the,with%20major%20downsides%20such%20as) [\[15\]](https://docs.getaurora.dev/guides/software/#:~:text=,this%20as%20a%20last%20resort) [\[23\]](https://docs.getaurora.dev/guides/software/#:~:text=,Developer%20Experience) [\[54\]](https://docs.getaurora.dev/guides/software/#:~:text=Distrobox%20Containers) Installing Software on Aurora | Aurora

<https://docs.getaurora.dev/guides/software/>

[\[5\]](https://getaurora.dev/en#:~:text=A%20unified%20app%20store) [\[6\]](https://getaurora.dev/en#:~:text=Homebrew%20on) [\[7\]](https://getaurora.dev/en#:~:text=Homebrew%20on) [\[18\]](https://getaurora.dev/en#:~:text=Preinstalled%20container%20tools) [\[19\]](https://getaurora.dev/en#:~:text=Developer%20tools%20are%20a%20click,away) [\[31\]](https://getaurora.dev/en#:~:text=Expanded%20hardware%20support) [\[38\]](https://getaurora.dev/en#:~:text=applications%20into%20one%20package) [\[51\]](https://getaurora.dev/en#:~:text=Aurora%20downloads%20and%20applies%20updates,take%20care%20of%20your%20updates) [\[52\]](https://getaurora.dev/en#:~:text=We%20built%20Aurora%20on%20completely,Resilient%20against%20failure) [\[53\]](https://getaurora.dev/en#:~:text=Welcome%2C%20it%27s%20your%20new%20desktop) Aurora - The Linux-based ultimate workstation

<https://getaurora.dev/en>

[\[8\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Use%20any%20Linux%20distribution%20inside,X11%2FWayland%29%2C%20and%20audio) [\[9\]](https://wiki.archlinux.org/title/Distrobox#:~:text=you%E2%80%99re%20more%20comfortable%20with,X11%2FWayland%29%2C%20and%20audio) [\[10\]](https://wiki.archlinux.org/title/Distrobox#:~:text=Distrobox%20allows%20users%20to%20partially,shared%20between%20host%20and%20container) [\[22\]](https://wiki.archlinux.org/title/Distrobox#:~:text=If%20you%20encounter%20an%20authorization,not%20starting%20for%20the%20fix) [\[24\]](https://wiki.archlinux.org/title/Distrobox#:~:text=When%20running%20graphical%20apps%2C%20you,Mesa%20package%20for%20the%20distro) [\[25\]](https://wiki.archlinux.org/title/Distrobox#:~:text=starting%20%20for%20the%20fix) [\[49\]](https://wiki.archlinux.org/title/Distrobox#:~:text=The%20main%20goal%20of%20Distrobox,home%20folder%20and%20application%20directories) Distrobox - ArchWiki

<https://wiki.archlinux.org/title/Distrobox>

[\[26\]](https://wiki.archlinux.org/title/Toolbox#X11_applications_not_starting#:~:text=Authorization%20required%2C%20but%20no%20authorization,Error%3A%20Can%27t%20open%20display%3A%20%3A0) [\[29\]](https://wiki.archlinux.org/title/Toolbox#X11_applications_not_starting#:~:text=Toolbox%20is%20a%20tool%20that,and%20the%20udev%20database%2C%20etc) Toolbox - ArchWiki

<https://wiki.archlinux.org/title/Toolbox>

[\[27\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=) [\[28\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=npm%20create%20astro%40latest) [\[39\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=) [\[40\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=) [\[41\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=Now%20we%20add%20the%20always,to%20date%20repository%20of%20paulcarroty) [\[42\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=And%20install%20with%20DNF) [\[43\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=Astro%20Blog) [\[44\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=codium%20) [\[45\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=Navigate%20into%20the%20directory%20,and%20launch%20VSCodium%20to%20begin) [\[47\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=touch%20) [\[48\]](https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/#:~:text=) Fedora Silverblue for Webdevelopment

<https://www.ioannishariskos.com/blog/fedora-silverblue-for-webdevelopment/>

[\[30\]](https://distrobox.it/useful_tips/#:~:text=Using%20the%20GPU%20inside%20the,container) [\[36\]](https://distrobox.it/useful_tips/#:~:text=Using%20nvidia) [\[37\]](https://distrobox.it/useful_tips/#:~:text=In%20case%20of%20podman%20container,manager%2C%20run) [\[46\]](https://distrobox.it/useful_tips/#:~:text=%5Bstorage%5D%20driver%20%3D%20) Distrobox

<https://distrobox.it/useful_tips/>

[\[33\]](https://distrobox.it/usage/distrobox-create/#:~:text=NVidia%20integration) Distrobox

<https://distrobox.it/usage/distrobox-create/>

[\[34\]](https://www.phoronix.com/news/Distrobox-1.5-Released#:~:text=With%20today%27s%20Distrobox%201,driver%20support%20with%20the%20container) Distrobox 1.5 Released With NVIDIA GPU Containers Support

<https://www.phoronix.com/news/Distrobox-1.5-Released>

[\[50\]](https://www.reddit.com/r/linux4noobs/comments/1jbh63y/installing_vpn_apps_on_immutable_distros_aurora/#:~:text=Installing%20VPN%20apps%20on%20Immutable,dev%2Fguides%2F) Installing VPN apps on Immutable distros (Aurora) : r/linux4noobs

<https://www.reddit.com/r/linux4noobs/comments/1jbh63y/installing_vpn_apps_on_immutable_distros_aurora/>
